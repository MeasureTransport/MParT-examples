%% Transport map from samples
%
% The objective of this example is to show how a transport map can be build 
% in MParT when samples from the target density are known.
%
% _The rendered live script version of this example can be obtain by doing "Open 
% as Live Script‚Äù from the Current Folder Browser or document tab or by doing 
% "Save as ..." and select the "MATLAB Live Code Files (*.mlx)" format._
%
%% Problem formulation
% From the definition of a transport map, the *function* $S(\mathbf{x}; \mathbf{w})$ 
% is invertible and have a positive definite Jacobian for any parameters $w$. 
% Combined with a probability density $\eta(\mathbf{r})$, we can therefore define 
% a density $\tilde{\pi}_w(x)$ induced by transforming $r$ with the inverse map 
% $S^{-1}(\mathbf{r})$. More precisely, the change of random variable formula 
% from the reference $\eta$ to the target $\tilde{\pi}$ reads:
% 
% $$\tilde{\pi}_{\mathbf{w}}(\mathbf{x}) = \eta(S(\mathbf{x}; \mathbf{w}))\left| 
% \det\nabla S(\mathbf{x}; \mathbf{w})\right|,$$
% 
% where $\det\nabla S$ is the determinant of the map Jacobian at the point $\mathbf{x}$. 
% We refer to $\tilde{\pi}_{\mathbf{w}}(\mathbf{x})$ as the *map-induced* density 
% or *pullback distribution* and will commonly interchange notation for densities 
% and measures to use the notation $\tilde{\pi} = S^{*} \eta$.
% 
% The objective of this example is, from samples $\mathbf{x}^i$, $i \in \{1,...,n\}$ 
% drawn according to a density $\pi$, build the map-induced density approximation 
% $\tilde{\pi}$.
%% Imports
% First, import |MParT| by adding the path to the installation folder and initialize 
% the |Kokkos| environment. Note that it is possible to specify the number of 
% threads used by |MParT| as an argument of the |KokkosInitialize| function. The 
% number of threads can only be set once per session.

addpath(genpath('~/Installations/MParT/matlab'))
num_threads = 8;
KokkosInitialize(num_threads);
%% 
% Default settings:

sd = 3; rng(sd);

set(0,'DefaultLineLineWidth',1.75)
set(0,'defaultAxesFontSize',12)
set(0,'defaultfigurecolor',[1 1 1])
set(0, 'DefaultAxesBox', 'on');
%% Reference density and samples
% In this example we use a 2D target density known as the *banana* density where 
% the unnormalized probability density, samples and the exact transport map are 
% known.
% 
% The banana density is defined as: $$ \pi(x_1,x_2) \propto N_1(x_1)\times N_1(x_2-x_1^2) 
% $$ where $N_1$ is the 1D standard normal density.
% 
% The exact transport map that transport $\pi$ to the 2D standard normal density 
% is defined as:
% 
% $$$$ {S}^\text{true}(x_1,x_2)= \left[ \matrix{x_1 \cr x_2 - x_1^2 } \right]$$$$ 
% 
% Samples from $\pi$ are generated by the following:

% Make target samples for training
num_points = 10000;
r = randn(2,num_points);
x1 = r(1,:);
x2 = r(2,:) + r(1,:).^2;
x = [x1;x2];

% Make target samples for testing
test_r = randn(2,5000);
test_x1 = test_r(1,:);
test_x2 = test_r(2,:)+test_r(1,:).^2;
test_x = [test_x1;test_x2];
%% Plot training samples:

figure
scatter(x(1,:),x(2,:),'MarkerFaceColor',[0 0.4470 0.7410],'MarkerEdgeColor','none','MarkerFaceAlpha',0.1);
xlabel('x_1')
ylabel('x_2')
legend('Target samples')
%% Map training
%% Defining objective function and its gradient
% To match the map induced density $\tilde{\pi}_{\mathbf{w}}(\mathbf{x})$ with 
% the samples, we can maximize the likelihood of observing the samples, which 
% is simply $$ \prod_{i=1}^N \tilde{\pi}_w(\mathbf{x}^i). $$
% 
% Numerically, it is typically easier to work with the log-likelihood instead 
% and we will therefore maximize the log likelihood to find the parameters $w$:
% 
% $$w^\ast = \underset{\mathbf{w}}{\text{argmax}}  \sum_{i=1}^N \log \tilde{\pi}_{\mathbf{w}}(\mathbf{x}^i).$$
% 
% Importantly, our use of triangular maps and a standard normal reference density 
% allows us to expand this objective into two independent problems: one for the 
% parameters $w_1$ defining the first component $S_1(x_1; w_1)$ of the map, and 
% one for the parameters defining the second component $S_2(x_{1:2}; w_2)$. In 
% general, for map component $k$, the objective function is given by
% 
% $$J_k(\mathbf{w}_k) = - \frac{1}{N}\sum_{i=1}^N \left( \log\eta\left(S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right) 
% + \log \frac{\partial S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)}{\partial x_k}\right)$$
% 
% and the resulting optimization problem is
% 
% $$\mathbf{w}_k^\ast = \underset{\mathbf{w}_k}{\text{argmin }}\,\, J_k(\mathbf{w}_k).$$
% 
% In order to use efficient gradient-based minimizer we need to define both 
% the objective and its gradient. The gradient is given by
% 
% $$\nabla_{\mathbf{w}_k}J_k(\mathbf{w}_k) = - \frac{1}{N}\sum_{i=1}^N \left(\left[\nabla_{\mathbf{w}_k}S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right]^T 
% \nabla_\mathbf{r}\log \eta \left(S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right) 
% - \frac{\partial \nabla_{\mathbf{w}_k}S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)}{\partial 
% x_k} \left[\frac{\partial S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)}{\partial x_k}\right]^{-1}\right),$$
% 
% where $\nabla_{\mathbf{w}_k}S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)$ is the Jacobian 
% of the map output with respect to the map parameters and $\nabla_\mathbf{r}\log 
% \eta \left(S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right)$ is the gradient of the 
% reference log-density evaluated at the map output. Note that for a standard 
% normal reference density, this expression simplifies to $\nabla_\mathbf{r}\log 
% \eta \left(S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right) = -S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)$.
% 
% Objective function and its gradient are defined at the end of this script.
%% Map parameterization
% With the separability property of the objective function mentionned above 
% we can parameterize and optimize components $S_1$ and $S_2$ independently.
%% First component $S_1$
% Theoritically the first component is $S_1^{\text{true}}(x_1)=x_1$. This parameterization 
% can be set with MParT as:

multis1 = [0;1];
mset1 = MultiIndexSet(multis1);
fixed_mset1 = mset1.Fix();
%% 
% Let's define the first component:

% Set-up first component and initialize map coefficients
map_options1 = MapOptions;

% Create map component
S1 = CreateComponent(fixed_mset1,map_options1);
%% Second component $S_2$
% Theoritically the second component is $S_2^{\text{true}}(x_1,x_2)=x_2^2-x_1$. 
% The corresponding multi-index set can exactly be define as:

multis2_true = [0 1;2 0];
mset2_true = MultiIndexSet(multis2_true);
fixed_mset2_true = mset2_true.Fix(); 
%% 
% Other multi-index sets which include the true multi-index set are any total 
% order expansion of order greater than one:

total_order2 = 2;
fixed_mset2 = FixedMultiIndexSet(2,total_order2);
%% 
% This parameterization will include terms: $x_1$, $x_2^2$, $x_1 x_2$ that are 
% not required to approximate the true map.
% 
% Let's define $S_2$ with one multi-index set.

map_options2 = MapOptions;
S2 = CreateComponent(fixed_mset2,map_options2);
%% Approximation before optimization
% Coefficients of map components are set to 0 upon creation. The triangular 
% transport map composed by $S_1$ and $S_2$ is defined by:

transport_map = TriangularMap([S1,S2]);
transport_map.SetCoeffs([S1.CoeffMap,S2.CoeffMap]);
%% 
% Reference density:

% For plotting and computing reference density
ngrid=100;
t = linspace(-5,5,ngrid);
[X_t,Y_t] = meshgrid(t,t);
ref_pdf_at_grid = mvnpdf([X_t(:) Y_t(:)]);

%% 
% Transport of target samples via $S$:

r_test_before_opt = transport_map.Evaluate(test_x);
%% 
% 

% Before optimization plot
figure
hold on
contour(X_t,Y_t,reshape(ref_pdf_at_grid,ngrid,ngrid))
scatter(r_test_before_opt(1,:),r_test_before_opt(2,:),'MarkerFaceColor',[0 0.4470 0.7410],'MarkerEdgeColor','none','MarkerFaceAlpha',0.1);
xlabel('r_1')
ylabel('r_2')
legend('Reference density','Pushed target samples through S')
title('Before optimization')

% Print initial coeffs and objective values
obj1=objective(S1.CoeffMap(), S1, test_x(1,:));
obj2=objective(S2.CoeffMap(),S2,test_x);

disp('==================')
disp('Starting coeffs component 1:')
disp(S1.CoeffMap())
disp(['Objective value for component 1: ',num2str(obj1)])
disp('==================')
disp('Starting coeffs component 2:')
disp(S2.CoeffMap())
disp(['Objective value for component 2: ' ,num2str(obj2)])
disp('==================')
%% 
% 
%% Optimization
% Optimization of $S_1$ and $S_2$ coefficients are performed independently.
%% Optimization of $S_1$
% For $S_1$ only samples of the first coordinate $x_1$ are required to solve 
% the minimization problem. 

% Optimize
obj = @(w) objective(w,S1,x(1,:));
w0 = S1.Coeffs();

options = optimoptions('fminunc','SpecifyObjectiveGradient', true, 'Display', 'none');
[~] = fminunc(obj, w0, options);
%% Optimization of $S_2$

% Optimize
obj = @(w) objective(w,S2,x);
w0 = S2.Coeffs();

options = optimoptions('fminunc','SpecifyObjectiveGradient', true, 'Display', 'none');
[~] = fminunc(obj, w0, options);
%% Approximation after optimization
%% Normality of pushed samples:
% Coefficients of |transport_map| are now updated, let's transport testing samples 
% again:

r_test_after_opt = transport_map.Evaluate(test_x);
%% 
% After optimization plot

% After optimization plot 
figure
hold on
contour(X_t,Y_t,reshape(ref_pdf_at_grid,ngrid,ngrid))
scatter(r_test_after_opt(1,:),r_test_after_opt(2,:),'MarkerFaceColor',[0 0.4470 0.7410],'MarkerEdgeColor','none','MarkerFaceAlpha',0.1);
xlabel('r_1')
ylabel('r_2')
legend('Reference density','Pushed target samples through S')
title('After optimization')

% Print final coeffs and objective
obj1=objective(S1.CoeffMap(), S1, test_x(1,:));
obj2=objective(S2.CoeffMap(),S2,test_x);
disp('==================')
disp('Final coeffs component 1:')
disp(S1.CoeffMap())
disp(['Objective value for component 1: ',num2str(obj1)])
disp('==================')
disp('Final coeffs component 2:')
disp(S2.CoeffMap())
disp(['Objective value for component 2: ' ,num2str(obj2)])
disp('==================')
%% 
% After optimization testing samples are visually distributed according to the 
% standard normal which tell us that the map has been computed accurately. Another 
% estimation of the approximation quality is to test normality of the pushed samples. 
% One simple way to do that is to compute first moments of the pushed test samples: 

% Print statistics of normalized samples 
disp('==================')
mean_of_map = mean(r_test_after_opt,2);
disp("Mean of normalized test samples:")
disp(mean_of_map')
disp('==================')
disp("Cov of normalized test samples:")
cov_of_map = cov(r_test_after_opt');
disp(cov_of_map)
disp('==================')
%% 
% Here mean should be 0 and covariance matrix should be identity.
%% Comparison with the true transport map
% Since the true transport map for this problem is known, we can compare directly 
% map evaluations component by component.

% Evaluation grid 

ngrid=100;
x1_t = linspace(-3,3,ngrid);
x2_t = linspace(-3,7.5,ngrid);
[xx1,xx2] = meshgrid(x1_t,x2_t);

xx = [xx1(:)';xx2(:)'];
%% 
% First component:

figure
hold on
plot(x1_t,x1_t)
plot(x1_t,S1.Evaluate(x1_t))
xlabel('x_1')
legend('true map','map approximation')
title('S_1')
%% 
% Second component:

map_eval_true = xx(2,:) - xx(1,:).^2;
map_eval_approx = S2.Evaluate(xx);

figure
hold on
contour(xx1,xx2,reshape(map_eval_true,ngrid,ngrid))
contour(xx1,xx2,reshape(map_eval_approx,ngrid,ngrid),'LineStyle','--')
xlabel('x_1')
ylabel('x_2')
legend('true map','map approximation')
title('S_2(x_1,x_2)')
%% 
% 
%% Contours of map-induced density
% We can also compare contours of the map-induced density and true unnormalized 
% density.

% For plotting and computing densities
true_pdf_at_grid = exp(target_logpdf(xx));
map_induced_pdf = pullback_pdf(transport_map,xx);

figure
hold on
contour(xx1,xx2,reshape(true_pdf_at_grid,ngrid,ngrid));
contour(xx1,xx2,reshape(map_induced_pdf,ngrid,ngrid),'LineStyle','--');
xlabel('x_1')
ylabel('x_2')
legend('Unnormalized target','TM approximation')
%% Custom functions needed for this example

function [L,dwL]=objective(coeffs,tri_map,x)
% Negative log likelihood objective
num_points = size(x,2);
tri_map.SetCoeffs(coeffs);

% Compute the map-induced density at each point
map_of_x = tri_map.Evaluate(x);
ref_of_map_of_x = log(normpdf(map_of_x));
log_det = tri_map.LogDeterminant(x);

% negative log-likelihood of the entire dataset
L = - sum(ref_of_map_of_x + log_det')/num_points;

if (nargout > 1)
    % Compute the inner product of the map jacobian (\nabla_w S) and the gradient (which is just -S(x) here)
    grad_ref_of_map_of_x = -tri_map.CoeffGrad(x,map_of_x);

    % Get the gradient of the log determinant with respect to the map coefficients
    grad_log_det = tri_map.LogDeterminantCoeffGrad(x);

    % Gradient of the negative log-likelihood
    dwL = - sum(grad_ref_of_map_of_x + grad_log_det,2)/num_points;
end
end
%% 
% 

function pdf = pullback_pdf(tri_map,x)
% definition of map induced pdf
   r = tri_map.Evaluate(x);
   log_pdf = log(mvnpdf(r'))+tri_map.LogDeterminant(x);
   pdf = exp(log_pdf);
end
%% 
% 

function logpdf = target_logpdf(x)
% definition of the banana unnormalized density
logpdf1 = log(normpdf(x(1,:)));
logpdf2 = log(normpdf(x(2,:)-x(1,:).^2));
logpdf = logpdf1 + logpdf2;
end