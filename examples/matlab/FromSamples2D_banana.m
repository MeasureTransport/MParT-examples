%% Transport map from samples
% The objective of this example is to show how a transport map can be build 
% in MParT when samples from the target density are known.
%% Problem formulation
% From the definition of a transport map, the *function* $S(\mathbf{x}; \mathbf{w})$ 
% is invertible and have a positive definite Jacobian for any parameters $w$. 
% Combined with a probability density $\eta(\mathbf{r})$, we can therefore define 
% a density $\tilde{\pi}_w(x)$ induced by transforming $r$ with the inverse map 
% $S^{-1}(\mathbf{r})$. More precisely, the change of random variable formula 
% from the reference $\eta$ to the target $\tilde{\pi}$ reads:
% 
% $$\tilde{\pi}_{\mathbf{w}}(\mathbf{x}) = \eta(S(\mathbf{x}; \mathbf{w}))\left| 
% \det\nabla S(\mathbf{x}; \mathbf{w})\right|,$$
% 
% where $\det\nabla S$ is the determinant of the map Jacobian at the point $\mathbf{x}$. 
% We refer to $\tilde{\pi}_{\mathbf{w}}(\mathbf{x})$ as the *map-induced* density 
% or *pullback distribution* and will commonly interchange notation for densities 
% and measures to use the notation $\tilde{\pi} = S^{*} \eta$.
% 
% The objective of this example is, from samples $\mathbf{x}^i$, $i \in \{1,...,n\}$ 
% drawn according to a density $\pi$, build the map-induced density approximation 
% $\tilde{\pi}$.
%% Imports
% First, import |MParT| by adding the path to the installation folder and initialize 
% the |Kokkos| environment. Note that it is possible to specify the number of 
% threads used by |MParT| as an argument of the |KokkosInitialize| function. The 
% number of threads can only be set once per session.

addpath(genpath('~/Installations/MParT/matlab'))
num_threads = 8;
KokkosInitialize(num_threads);
%% 
% Default settings:

sd = 3; rng(sd);

set(0,'DefaultLineLineWidth',1.75)
set(0,'defaultAxesFontSize',12)
set(0,'defaultfigurecolor',[1 1 1])
set(0, 'DefaultAxesBox', 'on');
%% Reference density and samples
% In this example we use a 2D target density known as the *banana* density where 
% the unnormalized probability density, samples and the exact transport map are 
% known.
% 
% The banana density is defined as: $$ \pi(x_1,x_2) \propto N_1(x_1)\times N_1(x_2-x_1^2) 
% $$ where $N_1$ is the 1D standard normal density.
% 
% The exact transport map that transport $\pi$ to the 2D standard normal density 
% is defined as:
% 
% $$$$ {S}^\text{true}(x_1,x_2)= \left[ \matrix{x_1 \cr x_2 - x_1^2 } \right]$$$$ 
% 
% Samples from $\pi$ are generated by the following:

% Make target samples for training
 

% code 

% code 

% code 

% code 
% Make target samples for testing

% code 

% code 

% code 

% code
%% 
% 
%% Plot training samples:

% code 

% code 

% code 

% code 

% code 

% code
%% Map training
%% Defining objective function and its gradient
% To match the map induced density $\tilde{\pi}_{\mathbf{w}}(\mathbf{x})$ with 
% the samples, we can maximize the likelihood of observing the samples, which 
% is simply $$ \prod_{i=1}^N \tilde{\pi}_w(\mathbf{x}^i). $$
% 
% Numerically, it is typically easier to work with the log-likelihood instead 
% and we will therefore maximize the log likelihood to find the parameters $w$:
% 
% $$w^\ast = \underset{\mathbf{w}}{\text{argmax}}  \sum_{i=1}^N \log \tilde{\pi}_{\mathbf{w}}(\mathbf{x}^i).$$
% 
% Importantly, our use of triangular maps and a standard normal reference density 
% allows us to expand this objective into two independent problems: one for the 
% parameters $w_1$ defining the first component $S_1(x_1; w_1)$ of the map, and 
% one for the parameters defining the second component $S_2(x_{1:2}; w_2)$. In 
% general, for map component $k$, the objective function is given by
% 
% $$J_k(\mathbf{w}_k) = - \frac{1}{N}\sum_{i=1}^N \left( \log\eta\left(S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right) 
% + \log \frac{\partial S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)}{\partial x_k}\right)$$
% 
% and the resulting optimization problem is
% 
% $$\mathbf{w}_k^\ast = \underset{\mathbf{w}_k}{\text{argmin }}\,\, J_k(\mathbf{w}_k).$$
% 
% In order to use efficient gradient-based minimizer we need to define both 
% the objective and its gradient. The gradient is given by
% 
% $$\nabla_{\mathbf{w}_k}J_k(\mathbf{w}_k) = - \frac{1}{N}\sum_{i=1}^N \left(\left[\nabla_{\mathbf{w}_k}S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right]^T 
% \nabla_\mathbf{r}\log \eta \left(S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right) 
% - \frac{\partial \nabla_{\mathbf{w}_k}S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)}{\partial 
% x_k} \left[\frac{\partial S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)}{\partial x_k}\right]^{-1}\right),$$
% 
% where $\nabla_{\mathbf{w}_k}S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)$ is the Jacobian 
% of the map output with respect to the map parameters and $\nabla_\mathbf{r}\log 
% \eta \left(S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right)$ is the gradient of the 
% reference log-density evaluated at the map output. Note that for a standard 
% normal reference density, this expression simplifies to $\nabla_\mathbf{r}\log 
% \eta \left(S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)\right) = -S_k(\mathbf{x}_{1:k}^i;\mathbf{w}_k)$.
% 
% Reference density

% code 
% Negative log likelihood objective

% code 

% code 

% code 

% code 
% Compute the map-induced density at each point

% code 

% code 

% code 
% Return the negative log-likelihood of the entire dataset

% code 

% code 

% code 

% code 

% code 
% Evaluate the map

% code 
% Now compute the inner product of the map jacobian (\nabla_w S) and the gradient (which is just -S(x) here)

% code 
% Get the gradient of the log determinant with respect to the map coefficients

% code 

% code
%% 
% 
%% Map parameterization
% With the separability property of the objective function mentionned above 
% we can parameterize and optimize components $S_1$ and $S_2$ independently.
%% First component $S_1$
% Theoritically the first component is $S_1^{\text{true}}(x_1)=x_1$. This parameterization 
% can be set with MParT as:

% code 

% code 

% code 
% Let's define the first component:
%% 
% Set-up first component and initialize map coefficients

% code 
% Create map component

% code
%% 
% 
%% Second component $S_2$
% Theoritically the second component is $S_2^{\text{true}}(x_1,x_2)=x_2^2-x_1$. 
% The corresponding multi-index set can exactly be define as:

% code 

% code 

% code 
% Other multi-index sets which include the true multi-index set are any total order expansion of order greater than one:

% code 

% code 
% This parameterization will include terms: $x_1$, $x_2^2$, $x_1 x_2$ that are not required to approximate the true map.
% Let's define $S_2$ with one multi-index set.

% code 

% code
%% Approximation before optimization
% Coefficients of map components are set to 0 upon creation. The triangular 
% transport map composed by $S_1$ and $S_2$ is defined by:

% code 

% code 
% Reference density:
% For plotting and computing reference density

% code 

% code 

% code 

% code 
% Transport of target samples via $S$:

% code
%% 
% Before optimization plot

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code 
% Print initial coeffs and objective

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code
%% 
% 
%% Optimization
% Optimization of $S_1$ and $S_2$ coefficients are performed independently.
%% Optimization of $S_1$
% For $S_1$ only samples of the first coordinate $x_1$ are required to solve 
% the minimization problem. Optimize

% code 

% code
%% Optimization of $S_2$
% Optimize

% code 

% code
%% Approximation after optimization
%% Normality of pushed samples:
% Building triangular map from components:

% code 

% code 
% Transport of testing samples from target:

% code
%% 
% Before optimization plot

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code 
% Print final coeffs and objective

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code
%% 
% After optimization testing samples are visually distributed according to the 
% standard normal which tell us that the map has been computed accurately. Another 
% estimation of the approximation quality is to test normality of the pushed samples. 
% One simple way to do that is to compute first moments of the pushed test samples: 
% Print statistics of normalized samples

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code 
% Here mean should be 0 and covariance matrix should be identity.
%% Comparison with the true transport map
% Since the true transport map for this problem is known, we can compare directly 
% map evaluations component by component.
% 
% Evaluation grid

% code 

% code 

% code 

% code 

% code
%% 
% First component

% code 

% code 

% code 

% code 

% code 

% code 

% code 
% Second component
%%
% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code
%% 
% 
%% Contours of map-induced density
% We can also compare contours of the map-induced density and true unnormalized 
% density.
% 
% Map induced pdf

% code 

% code 

% code 

% code 
% True density

% code 

% code 

% code 

% code 

% code 

% code 

% code
%% 
% Comparison grid

% code 

% code 

% code 

% code 

% code 
% For plotting and computing densities

% code 

% code 

% code 
%SCA = ax.scatter(test_x[0,:2000],test_x[1,:2000], facecolor='blue', alpha=0.1,label='Target samples')

% code 

% code 

% code 

% code 

% code 

% code 

% code 

% code 
matlab.internal.liveeditor.openAndConvert('FromSamples2D_banana.mlx','FromSamples2D_banana.m')